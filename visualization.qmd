---
title: "Untitled"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# 5. Creating Visualizations from Data Packages

As the title suggests, this section will aim to describe how to create plots in different ways with a focus on reproducibility and collaboration. In this perspective, I believe making descriptive comments about you wrangle and plot your data is key, especially with collaboration in mind - both for your own and others sake. Doing this should make it much easier for yourself and others to pick up the work where you left of.

### Prior to plotting

Since we already have a data package that should cleanup and ready our data (or at least close to ready) for visualization, we can simply import the data from this package. The package from which we will import data is organized by test, meaning one xlsx file per test with no other info than what was measured in each specific test. Therefore it is necessary to wrangle and tidy the data a bit further, to get all the information we would like to visualize (such as what age group, condition and allocation each participant had). An almost surprising amount of time can go into this process before you even start plotting, but tidy data will make plotting quite a lot easier.

```{r, data import and wrangling}
library(tidyverse)
#library(dplyr)
library(writexl)

## Importing the data from the data package

humac.dat <- reliefdata::relief_humac # this is the peak torque test data
write_xlsx(humac.dat, "relief_humac.xlsx") # used for data sharing until data package is up and running

condition <- reliefdata::relief_volume %>% # this is info about volume condition
  mutate(participant = as.character(participant))
write_xlsx(condition, "relief_volume.xlsx") # used for data sharing until data package is up and running

participants <- reliefdata::relief_participants %>% # this is info about age group and allocation
  
  mutate(age_group = if_else(age < 40, "yng", "old"))
write_xlsx(participants, "relief_participants.xlsx") # used for data sharing until data package is up and running


## Joining the data sets

# Joining condition and participant info
humac.dat <- humac.dat %>%
  # Using left_join to add the info from condition and participants to humac.dat
  left_join(condition) %>%
  # There is no "arm" data from this test, so we exclude it
  select(-arm) %>% 
  
  left_join(participants) %>%
  
  mutate(age_group = factor(age_group, levels = c("yng", "old")),
         # using factor() to sort the order of the respective variables, meaning they will always be displayed in this order in analyses and plots - unless manually overridden. I think this is a nice way to ensure consistency across multiple plots.
         
         condition = factor(condition, levels = c("low", "mod")),
         
         time = factor(time, levels = c("pre", "mid",  "post")),
         
         speed = factor(speed, levels = c("0", "60", "120", "240")),
         
         allocation = factor(allocation, levels = c("int", "con")),
         # case_when makes sure that control participants are not grouped with a volum                condition
         condition = case_when(participant %in% c("3071", "3075", "3076", 
                                                  "3083", "3084", "3085",
                                                  "3086", "3090", "3091",
                                                  "3094") ~ "none", TRUE ~ condition))

# Now we have a complete data set with the measurements from the humac test, as well as information about what age group, allocation and condition all the participants had. At this point (or even before) you might want to use the glimpse() function to have a look at the data set and all the variables it contains - here you can also check that what we've joined in actually is there!

glimpse(humac.dat)

## Further data wrangling
# The data set contains 2x test per time point, therefore one could either make an average of the two measurements oer time point or take the highest value from each. I've decided to take the highest value observed at each time point for analysis. This can be done using the summarise() function alone, however, this produced a lot of "improper" NA's and corresponding errors. Therefore I've included the below code, which makes a functions that returns proper NA values where all values are NA for a group.


safe_max <- function(x) {
  if (all(is.na(x))) return(NA_real_)
  max(x, na.rm = TRUE)
}

safe_min <- function(x) {
  if (all(is.na(x))) return(NA_real_)
  min(x, na.rm = TRUE)
}


## Step-by-step explanation:
#1. function(x) - This creates a function that takes one input called x (which will be your vector of values)
#2. if (all(is.na(x))) - This checks the condition:

#is.na(x) checks each element and returns TRUE/FALSE for each
#all() checks if ALL elements are TRUE
#So this asks: "Are ALL values in x missing (NA)?"

#3. return(NA_real_) - If all values are NA:

#Return NA_real_ (which is specifically a numeric NA, as opposed to NA_character_ or NA_integer_)
#return() immediately exits the function

#4. max(x, na.rm = TRUE) - If NOT all values are NA:

#Calculate the maximum, ignoring any NAs that exist
#This line only runs if the if condition is FALSE

## Get max values for all outcomes
# With the new "safe_max" variable, we can safely get the highest measurements without producing erroneous NAs.

max.dat <- humac.dat %>%
  filter(!participant == "3012") %>% # Missing data
  group_by(participant, time, leg, speed, condition, age_group, allocation, sex) %>%
  summarise(pt_max = safe_max(pt),
            power_max = safe_max(rep_power),
            work_max = safe_max(rep_work),
            tt_min = safe_min(pt_tt),
            angle = mean(pt_angle, na.rn = TRUE),
            .groups = "drop")


## Reshape the data to long format
# This simply formats the data to where each observation is stored in its own row, with variables spread across columns - thus minimizing redundancy. This typically makes the data frame more tidy, and is quite practical for selecting variables, faceting etc, and will remain the go-to data frame for all the plots here. 

long.dat <- max.dat %>%
  pivot_longer(names_to = "outcome",
               values_to = "value",
               cols = c(pt_max, power_max, work_max, tt_min, angle))


```

### Plotting some figures

Now that the data is imported and tidied up, it can be a good idea to start with a simple plot just to get an overview of the data. The backbone of all these plots will be the ggplot() function from ggplot2 (loaded by tidyverse), and in addition we will also use cowplot for some more toys. Briefly, ggplot2 may be considered a layered grammar of graphics, where we can use its tools to build a plot from data through mapping variables to aesthetics, geometric objects, facets, and adding themes and annotations [kursnotater, wilkinson10].

Before trying to make "the one and only" plot, it's a good idea to start simple just to have a look at what you're working with - this is also useful to do before any statistical analysis. Since we've already wrangled the data into a tidy long format, and glimpsed (glimpse()) the variables we are interested in, we can go ahead and plot it.

**Plot 1: Simple Visualization**

```{r, Plot1}


## Simple overview plot

overview.plot <- long.dat %>%
  ggplot(aes(speed, value, group = age_group, color = age_group)) +
  geom_point() + # mapps data to points in the plot
  theme_minimal()

# So, this simple plot does not really do much other than confirming that there is data and its being mapped to the aesthetics we call. Since this data set has multiple levels of grouping, it would be a good idea to add some facets via the facet_wrap() function. Further, this plot generated a warning message that 876 rows either contained missing values or values outside the scale range was being removed - this is presumably due to using not specifying what outcome we wanted to look at, thus including all outcomes with a wide difference in scale. 
  
## Faceting by angular velocity  

facet.plot <- long.dat %>%
  filter(outcome == "pt_max") %>% # this filters out any other outcome than maximal peak torque, to deal with the scale range issue in the previous plot
  ggplot(aes(time, value, group = age_group, color = age_group)) +
  geom_point() +
  facet_wrap(~speed) + #this creates facets in the plot, depending on angular velocity
  
  theme_minimal()

facet.plot

```

This is an alright start, we've got the angular velocity separated by facets, and data points colored by age group. However, if we are interested in visualizing the change from baseline to post, there is more to consider. We may assume that there is a difference depending on if the participant was young or old, exercised with a low or moderate volume, and/or if they were in the intervention or control group, so this must be accounted for in the plot. This can be displayed in a couple different ways by using the package cowplot with simultaneous faceting, to make sure we get all the groups we want and also not totally flooding one single graph.

**Plot 2: Individual Changes in Peak Torque at 0 (isometric), 60, 120 and 240 d/S**

In this example plot, we create one plot per angular velocity, and facet by age group and allocation. This will give us a good overview of what happens in each of the groups from baseline to the half-way mark, and then to post.

```{r, Plot2}

## Peak torque Isometric

plot.isom <- long.dat %>%
  filter(speed == "0",
         outcome == "pt_max") %>% # Here we specify what angular velocity and outcome data we want
  
  ggplot(aes(x = time, y = value, group = interaction(participant, leg))) + # the interaction(participant/leg) creates a unique grouping variable combining participant and leg - so we can account for the fact that the participants exercised with a unilateral protocol
  
  geom_line(aes(color = condition), alpha = 0.3) +
  geom_point(aes(color = condition), alpha = 0.3, size = 1) + # color = condition makes sure the points and lines are colored by condition
  
  facet_wrap(vars(age_group, allocation), scales = "fixed") + # vars() can be used like this when you would like to facet_wrap on multiple groupings. Scales are set to "fixed" to have the same scale for all the plots in our final cowplot
  
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") + # this sets the color of geom_line and geom_point, ideally to something easily distinguishable 
  
  labs(title = "",
       subtitle = "",
       x = "",
       y = "Peak Torque (Nm)") + # this can be changed to any suitable title, subtitle etc. when using cowplot to grid multiple plots, you might want to remove these ("") for most of or all your plots, since a common title etc. can be made in the cowplot. 
  
  theme_minimal() +
  theme(legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        axis.text.x = element_blank())#,
       # strip.text = element_blank()) # these theme() changes are part of the final cosmetic adjustment of each plot. For instance strip.text = element_blank() removes facet labels, and this could be useful to apply in some of the plots as long as they follow the same pattern. 

# The following three plots will be copies of the above one, with slight differences in theme/labs to fit together in the cowplot. 

## Peak torque 60

plot.60 <- long.dat %>%
  filter(speed == "60",
         outcome == "pt_max") %>%
  
  ggplot(aes(x = time, y = value, group = interaction(participant, leg))) +
  geom_line(aes(color = condition), alpha = 0.3) +
  geom_point(aes(color = condition), alpha = 0.3, size = 1) +
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +
  labs(title = "",
       subtitle = "",
       x = "",
       y = "") +
  theme_minimal() +
  theme(legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        axis.text.x = element_blank())#,
        #strip.text = element_blank())

## Peak torque 120

plot.120 <- long.dat %>%
  filter(speed == "120",
         outcome == "pt_max") %>%
  ggplot(aes(x = time, y = value, group = interaction(participant, leg))) +
  geom_line(aes(color = condition), alpha = 0.3) +
  geom_point(aes(color = condition), alpha = 0.3, size = 1) +
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +
  labs(title = "",
       subtitle = "",
       x = "Time",
       y = "Peak Torque (Nm)") +
  theme_minimal() +
  theme(legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_blank(),
        strip.text = element_blank())

## Peak torque 240

plot.240 <- long.dat %>%
  filter(speed == "240",
         outcome == "pt_max") %>%
  ggplot(aes(x = time, y = value, group = interaction(participant, leg))) +
  geom_line(aes(color = condition), alpha = 0.3) +
  geom_point(aes(color = condition), alpha = 0.3, size = 1) +
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +
  labs(title = "",
       subtitle = "", #Each line represents one leg from one participant
       x = "Time",
       y = "") +
  theme_minimal() +
  theme(legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_blank(),
        strip.text = element_blank())


library(cowplot)

## Combining the plots
# This is where we can use cowplot to combine all the four plots above into one plot - and yes, you can combine different cowplots into an even bigger plot if you wanted to. 

# This one is quite basic, but suits our current needs quite well. The plots will appear in the order they are called, and you can define how many columns and rows you want with ncol and nrow. Since we use theme() to hide the legend of two of the plots here, we can adjust the relative hight of the upper row vs. the lower with rel_heights. 

ptfig <- plot_grid(
  plot.isom + theme(legend.position = "none"),
  plot.60 + theme(legend.position = "none"),
  plot.120,
  plot.240,
  ncol = 2,
  nrow = 2,
  labels = c("A) 0 d/s", "B) 60 d/s", "C) 120 d/s", "D) 240 d/s"),
  label_size = 10,
  rel_heights = c(0.8, 1) 
)


ptfig



```

**Plot 3: Mean Change Peak Torque per Age Group - with raw data**

While it may be fascinating to look at all the individual lines in these plots, it's not necessarily easy to discern what happens in the respective groups here. So, another option is to summarize the change in peak torque instead of having all the individual lines. In addition we can use either errorbars or map the individual data to display the variation in the data frame - technically you could do both, but that would be quite messy in our case.

```{r, Plot3}

# Set seed for jitter

set.seed(1) # further down we will use position_jitter to spread out our data points a bit more, set.seed(1) simply makes this spread reproducible instead of randomly changing every time you run the code. Notably the (1) doesnt really matter, it could be (22), as long as its the same every time for reproducibility. 

# The setup here will be quite similar to the previous plot, but we do need to perform some statistical transformation using summarise() to get the mean change instead of all the individual changes. 

# Isometric 

# First we create a data frame containing only the isometric angular velocity and the outcome peak torque. The reason for this, is that we would like to use this specific data frame for our geom_points further down, after we have summarised the data. Thus we need a separate data frame. 
isom.dat <- long.dat %>%
  filter(speed == "0",
         outcome == "pt_max")

  
plot.isommean <- isom.dat %>%
  
#summarising means - before summarising we select what we would like to group our data by with group_by(), and we then use .groups = "drop" when the summarizing is completed.
  group_by(age_group, allocation, condition, time) %>%
  summarise(mean = mean(value, na.rm = TRUE),
            sd = sd(value, na.rm = TRUE),
            .groups = "drop" ) %>%
  
  #creating the plot
  ggplot(aes(x = time, y = mean, color = condition, group = condition)) +
  
  # Here we can use two instances of geom_point to map out both the mean data and the indivdual data. For the mean data, we also add geom_line to connect the dots depending on condition, and we make sure they dont overlap too much by using position_dodge with identical coordinates. 
  # Mean data
  geom_line(linewidth = 1, position = position_dodge(.5)) +
  geom_point(shape = 21, aes(fill = condition), color = "black",
             size = 3, stroke = 1, position = position_dodge(.5)) +
  # Individual data
  geom_point(data = isom.dat, # Here we add the isom.dat with all the individual values intact
             aes(x = time, y = value,
                 color = condition, group = condition),
                 size = 1.5, # adjusts the size of these data points
                 alpha = 0.3, # adjusts the alpha, might be a good idea to have a lower alpha and size compared to the mean data points
             position = position_jitter(width = 0.2)) +
  
# Here's an example of how to implement errorbars instead, if thats your jam
#  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
#                width = 0.1, linewidth = 0.8, position = position_dodge(.2)) +

  
  
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +  # <-- hide the color legend
  
  scale_fill_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                    guide = "none") +  # <-- add fill scale
  
  labs(title = "",
       subtitle = "",
       x = "",
       y = "Peak Torque (Nm)") +
  
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_blank(),
        axis.line.x = element_blank())


# The following three plots will be copies of the above one, with slight differences in theme/labs to fit together in the cowplot. 

# 60 d/s

dat.60 <- long.dat %>%
  filter(speed == "60",
         outcome == "pt_max")

plot.60mean <- dat.60 %>%
  #summarising means
  group_by(age_group, allocation, condition, time) %>%
  summarise(mean = mean(value, na.rm = TRUE),
            sd = sd(value, na.rm = TRUE),
            .groups = "drop" ) %>%
  
  #creating the plot
  ggplot(aes(x = time, y = mean, color = condition, group = condition)) +
  
  geom_line(linewidth = 1, position = position_dodge(.5)) +
  geom_point(shape = 21, aes(fill = condition), color = "black",
             size = 3, stroke = 1, position = position_dodge(.5)) +
  geom_point(data = dat.60,
             aes(x = time, y = value,
                 color = condition, group = condition),
                 size = 1.5,
                 alpha = 0.3,
             position = position_jitter(width = 0.2)) +
 # geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
#                width = 0.1, linewidth = 0.8, position = position_dodge(.2)) +
  
  
  
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +  # <-- hide the color legend
  
  scale_fill_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                    guide = "none") +  # <-- add fill scale
  
  labs(title = "",
       subtitle = "",
       x = "",
       y = "") +
  
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_blank(),
        axis.line.x = element_blank())


# 120 d/s

dat.120 <- long.dat %>%
  filter(speed == "120",
         outcome == "pt_max")

plot.120mean <- dat.120 %>%
  #summarising means
  group_by(age_group, allocation, condition, time) %>%
  summarise(mean = mean(value, na.rm = TRUE),
            sd = sd(value, na.rm = TRUE),
            .groups = "drop" ) %>%
  
  #creating the plot
  ggplot(aes(x = time, y = mean, color = condition, group = condition)) +
  
  geom_line(linewidth = 1, position = position_dodge(.5)) +
  geom_point(shape = 21, aes(fill = condition), color = "black",
             size = 3, stroke = 1, position = position_dodge(.5)) +
  geom_point(data = dat.120,
             aes(x = time, y = value,
                 color = condition, group = condition),
                 size = 1.5,
                 alpha = 0.3,
             position = position_jitter(width = 0.2)) +
  
 # geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
  #              width = 0.1, linewidth = 0.8, position = position_dodge(.2)) +
  
  # adding in the raw data
  
  
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +  # <-- hide the color legend
  
  scale_fill_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                    guide = "none") +  # <-- add fill scale
  
  labs(title = "",
       subtitle = "",
       x = "Time",
       y = "Peak Torque (Nm)") +
  
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        strip.text = element_blank())


# 240 d/s

dat.240 <- long.dat %>%
  filter(speed == "240",
         outcome == "pt_max")

plot.240mean <- dat.240 %>%
  #summarising means
  group_by(age_group, allocation, condition, time) %>%
  summarise(mean = mean(value, na.rm = TRUE),
            sd = sd(value, na.rm = TRUE),
            .groups = "drop" ) %>%
  
  #creating the plot
  ggplot(aes(x = time, y = mean, color = condition, group = condition)) +
  
  geom_line(linewidth = 1, position = position_dodge(.5)) +
  geom_point(shape = 21, aes(fill = condition), color = "black",
             size = 3, stroke = 1, position = position_dodge(.5)) +
  geom_point(data = dat.240,
             aes(x = time, y = value,
                 color = condition, group = condition),
                 size = 1.5,
                 alpha = 0.3,
             position = position_jitter(width = 0.2)) +
  
  #geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
   #             width = 0.1, linewidth = 0.8, position = position_dodge(.2)) +
  
  # adding in the raw data
  
  
  facet_wrap(vars(age_group, allocation), scales = "fixed") +
  
  scale_color_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                     name = "Training Volume") +  # <-- hide the color legend
  
  scale_fill_manual(values = c("low" = "#E69F00", "mod" = "#56B4E9", "none" = "gray50"),
                    guide = "none") +  # <-- add fill scale
  
  labs(title = "",
       subtitle = "",
       x = "Time",
       y = "") +
  
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        strip.text = element_blank())


# Combinding the plots

ptimeanfig <- plot_grid(
  plot.isommean + theme(legend.position = "none"),
  plot.60mean + theme(legend.position = "none"),
  plot.120mean,
  plot.240mean,
  ncol = 2,
  nrow = 2,
  labels = c("A) Isometric", "B) 60 d/s", "C) 120 d/s", "D) 240 d/s"),
  label_size = 10,
  rel_heights = c(0.8, 1)
)



ptimeanfig

```

**Plot 4: Mean Peak Torque change in a Hill curve format**

If we were interested in only comparing the age groups and intervention vs. control, we could combine all of that into one plot. A cool and illustrative plot with this type of data would be to make a force-velocity curve, first developed by A. V. Hill in 1938 [source], and compare the age groups across angular velocities. We do assume that force development is reduced when angular velocity is increased, so it lets visualize it!

```{r, Plot4}

# Calculating group means
curve.sum <- long.dat %>%
  filter(outcome == "pt_max") %>% # this time we're including all angular velocities, so we only filter the outcome
  
  group_by(age_group, allocation, time, speed) %>%
  
  summarise(mean = mean(value, na.rm = TRUE),
            #sd = sd(value, na.rm = TRUE),
            .groups = "drop") %>%
  
  # This time we combine age_group and allocation, since volume condition is not on the menu. 
  mutate(group = paste(age_group, allocation, sep = "_"))
  


# Plot 2: Single plot showing everything (might be busy)
curve.plot <- curve.sum %>%
  
  ggplot(aes(x = speed, y = mean, color = group, linetype = time, 
             group = interaction(group, time))) +
  
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  
  labs(x = "Angular Velocity (d/s)",
       y = "Peak Torque (Nm)",
       color = "Group",
       linetype = "Time Point",
       title = "") +
  
  scale_color_manual(values = c("yng_int" = "#E69F00",
                                  "old_int" = "#56B4E9",
                                  "old_con" = "gray50"),
                     labels = c("yng_int" = "Young Intervention", 
                                "old_int" = "Old Intervention", 
                                "old_con" = "Old Control")) +
  
  theme_classic() +
  theme(legend.position = "bottom")


curve.plot




```

